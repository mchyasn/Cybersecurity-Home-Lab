# Solution and Walk-Through: Maldocs Analysis Exercise - Living Off The Land with Powershell

**Please note, the exercise files are in a password-protected archive using a password of:** ***infected***

## Challenge Questions

1. [What streams contain macros in this document?](#what-streams-contain-macros-in-this-document?)

2. [This document contains an obfuscated base64 encoded string, what value is used to pad (or obfuscate) this string?](#extracting-the-macros)

3. [This document contains a user-form, what is the name?](#this-document-contains-a-user-form-what-is-the-name)

4. [What index is responsible for the storage of the base64-encoded string?](#what-index-is-responsible-for-the-storage-of-the-base64-encoded-string)

5. [What is the purpose of the base64 encoded string?](#what-is-the-purpose-of-the-base64-encoded-string)

6. [What important IOCs are contained within the base64 encoded string?](#what-important-IOCs-are-contained-within-the-base64-encoded-string)

7. [What WMI class is used to create the process to launch the trojan?](#what-WMI-class-is-used-to-create-the-process-to-launch-the-trojan)

8. [What malware family was this maldoc attempting to drop?](#What-malware-family-was-this-maldoc-attempting-to-drop)

## Getting Started

It's often best to begin by investigating the file type of the document using the file utility, this will ensure that we’re using the right tools for the job.

<img src=https://user-images.githubusercontent.com/1920756/101266636-503e4b00-3716-11eb-8b83-0e83e42ad56e.png width=800 />

As you can see from the output, we have a "Word" document.

## What streams contain macros in this document?
Now that we have identified our sample as an office document, we can utilize tools such as OLEDUMP. Let’s use OLEDUMP to investigate the structure of the document – we are primarily interested in seeing if it contains macros at this point.

<img alt="Oledump output" src="https://user-images.githubusercontent.com/1920756/101266674-c2169480-3716-11eb-8ba3-7b681899eabe.png" width="800" />

```
> oledump.py ea50158bcef30d51e298846c056649c3
```

Streams that contain macros are indicated with an upper or lower case “M” – so this document contains at least three macro streams in 13, 15 and 16. The difference between the upper and lower case M is that streams with an uppercase M contain code, where the lowercase M streams only define a module (and there is no code). Often times you’ll see streams with a lower case M that are associated with a user form, it’s a module where actions/events from the user form could be created. Since user forms are normally just used to store content, they remain empty. In this document, you can see that stream 16 is associated with a user form – all of the streams that end with an ‘f’ and an ‘o’ are objects from the user form and help to highlight this relationship.

## Extracting the Macros

We can now extract the macros using oledump. Use the “-s” switch with the index number and “-v” to decode, you can also redirect the output to a text file to analyze in a text editor using the output redirection operator (">").

```
> oledump.py -s 13 -v ea50158bcef30d51e298846c056649c3 > s13
```

When you are uncertain where to begin analysis, the best place to start is usually the entry point. Macro code can be automatically executed during certain document life-cycle events, such as when the document is opened or closed. If you investigate stream 13, you’ll see the Document_Open event, which simply calls another function. This means that all of the code we need to investigate is in stream 15.

<img alt="auto open" src="https://user-images.githubusercontent.com/1920756/101266727-6ac4f400-3717-11eb-9014-603640cd539a.png" width=800 />

With interpreted code, a common strategy for obfuscation is to deobfuscate and build new scirpts/code on the fly – which means we’re looking for ways that the code can be executed. This also means that we can look for large strings and trace from there. To assist with this, I often turn on word wrap in my text editor, this helps to “reveal” such strings.
<br><br>
In this document, the variable “haothkoebtheil” is initially assigned a large string value, then passed to the function “juuvzouchmiopxeox”. While at first glance this may appear to be base64 encoded content, it contains some invalid characters – this function call must have something to do with that....

<img alt="funny string" src="https://user-images.githubusercontent.com/1920756/101266746-92b45780-3717-11eb-874b-5f86c530e8b5.png"  width=800/>

Inside this function, we can trace the input to a call to split, which is assigned to the “feaxgeip” variable.

<img alt="split" src="https://user-images.githubusercontent.com/1920756/101266765-c1cac900-3717-11eb-9fa7-75ec7c434bc7.png" width=800 />

This command will use the second argument to split the string, storing the results in an array. The variable “feaxgeip” is then passed to a join command – the variable “eihnx” is not set and will be empty, this then joins the array as a single string. This is assigned to the variable “jaquhoiqu”, which is then assigned to the function name – this is the VBA way of returning a value.

<img alt="join" src="https://user-images.githubusercontent.com/1920756/101266774-da3ae380-3717-11eb-8240-81551c0365e7.png" width=800 />

Essentially, the string ```2342772g3&*gs7712ffvs626fq``` is obfuscation or padding that is removed before the valid base64 encoded string is revealed. One more problem though, this is a rather short string. If you look at the original string definition, it contains some concatentation:

<img alt="pattern" src="https://user-images.githubusercontent.com/1920756/101266811-1ff7ac00-3718-11eb-9681-2ed51f7e69e7.png" width=800 />

## This document contains a user-form, what is the name?

Streams that end with an *f* and an *o* are objects from the user form and can be identified as such in *oledump* when investigating the document structure.

<img alt="Userform objects" src="https://user-images.githubusercontent.com/1920756/102922696-11b5c980-4454-11eb-981e-58f186c0d25c.png" width=800 />

The name of the user-form is indicated in the this output as well - the name of the userform for this document is *roubhaol*. Recognizing the name of the form can be helpful when tracing macro code to help identify when content from a user-form object is being used.

If you have a version of Office available, you can also view the document in the Developer IDE to better understand the structure of the document as well as the names for key objects. 

<img alt="Userform objects in Office IDE" src="https://user-images.githubusercontent.com/1920756/102922962-812bb900-4454-11eb-8986-84fd477bee83.png" width=800 />

In the previous screenshot, you can clearly see the name of any user-form.

## What index is responsible for the storage of the base64-encoded string?

Recall that the name of our code-less macro stream was “roubhaol”, which is part of this variable being used. This code represents access to a form object from this user form, which means that a much larger portion of the string is stored there. We have a few options for obtaining this content – we could just run strings on the document and identify it in the output, or we could investigate large streams using OLEDUMP. In this case, either solution is fine.
<br><br>
If we use OLEDUMP, the stream that stands out is index 34. The third column represents the size of the stream and sense stream 34 is not only a large stream (15164), it’s also a form object due to the trailing ‘o’.

<img alt="form content" src="https://user-images.githubusercontent.com/1920756/101266868-b9bf5900-3718-11eb-92e9-eea798c7e2ab.png" width=800 />

You can dump this content using the following command: 

```
> oledump.py -s 34 ea50158bcef30d51e298846c056649c3
```

This definitely looks like our content, it’s a long strong that we can see the value used to split on earlier repeating in it. If you want to dump this content you can’t just redirect the output to a file, this will include all of the content you see in your terminal. Instead, you need to add the “- d” switch which will dump just the stream content. Redirect this to a file and you have the obfuscated base64 string.

```
> oledump.py -s 34 -d ea50158bcef30d51e298846c056649c3 > obfuscated_b64.bin
```

Now that you have this content in a file, you can open it up with a text editor. There may be some non-printable and/or unnecessary ASCII characters at the beginning and end of this content – using your text editor remove this content. The last step is to replace the value that is split on and you should have your base64 encoded string!

<img alt="decoded" src="https://user-images.githubusercontent.com/1920756/101266942-3c481880-3719-11eb-8d26-0c2ff1267fbc.png" width=800 />

## What is the purpose of the base64 encoded string?

The base64 encoded string is not only a base64 encoded string, but also the commands necessary to execute it as a Powershell script. 

```
> powershell -e
```

The *-e* argument signifies a base64 encoded value that Powershell will decode and then execute. This technique avoids writing the Powershell script to the fileystem and it remains memory-resident only.

## What important IOCs are contained within the base64 encoded string?

The last step is to decode the base64 string. We can continue to use the terminal to help with this – remove all content except the base64 string. In this example, that would be everything before the value “JABsA...” – so the powershell command. Save the file, then use the cat and base64 utilities, piping the output to a file:

```
> cat encoded_b64 | base64 -d > decoded_ps.txt
```

<img alt="iocs" src="https://user-images.githubusercontent.com/1920756/101267179-ac579e00-371b-11eb-8c0b-67472959d6b6.png" width=800 />

There are a number of additional steps from here – you can download any payloads from the active URLs to get file hashes and follow-on C2 activity, you can search network logs to see if any requests have been made to these URLs, you can try to automate this process!

## What WMI class is used to create the process to launch the trojan?

In the extracted Powershell script, after the domains are defined there is a FOR loop that iterates through each domain attempting to download the trojan. The Powershell checks the response size with an *IF* statement, if the response is greater than or equal to 24751, then it attempts to execute the payload by using the *Win32_Process* WMI class.

<img alt="WMI Class" src="https://user-images.githubusercontent.com/1920756/102923449-61e15b80-4455-11eb-9152-1cc4ac924e1e.png" width=800 />

Documentation on MSDN - [https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process).

## What malware family was this maldoc attempting to drop?

[Emotet - SHA256](https://paste.cryptolaemus.com/emotet/2020/07/22/emotet-malware-IoCs_07-22-20.html)
<br><br>
The obfuscation employed here is rather mild and there may be quicker and easier ways to get the base64 content. For example, if there is no anti-analysis a sandbox may make quick work of it:

<img alt="dynamic" src="https://user-images.githubusercontent.com/1920756/101267221-07899080-371c-11eb-8ca8-4580c8e0b7e8.png" width=800 />